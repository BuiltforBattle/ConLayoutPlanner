<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cosplay World Layout Planner</title>
  <style>
    body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
}
    #sidebar { width: 250px; padding: 20px; background: #f4f4f4; border-right: 1px solid #ccc; overflow-y: auto; }
    #grid-container {
      flex: 1;
      position: relative;
      background: #fff;
      overflow: auto;
      padding: 0; /* ‚úÖ Remove padding */
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    #grid-wrapper {
      display: block;
      border: 4px solid #000;
      background: #fdfdfd;
      margin: 20px 0; /* optional spacing */
    }
    #grid { position: relative; display: grid; }
    .cell { border: .15px solid #ddd; box-sizing: border-box; }
    .booth { position: absolute; border: 2px solid #333; color: #000; font-size: 10px; display: flex; justify-content: center; align-items: center; overflow: hidden; cursor: grab; transform-origin: top left; }
    .Vendor { background: rgba(0, 128, 255, 0.5); }
    .Artist { background: rgba(0, 255, 128, 0.5); }
    .Guest { background: rgba(255, 128, 0, 0.5); }
    .Stage { background: rgba(255, 0, 128, 0.5); }
    label, input, select, button { display: block; margin-bottom: 10px; width: 100%; }
    
    #boothList { margin-top: 20px; font-size: 12px; }
    #boothList div { margin-bottom: 4px; }
    #boothList::-webkit-scrollbar {
      width: 6px;
    }
    #boothList::-webkit-scrollbar-thumb {
      background-color: #888;
      border-radius: 3px;
    }
    .booth.selected {
      outline: 3px solid red;
      z-index: 999;
    }

  </style>
</head>
<body>
  <header style="background:#222;color:#fff;text-align:center;padding:12px 0;font-size:1.4em;font-weight:bold;">Convention Layout Planner</header>
  <main style="flex: 1; display: flex; overflow: hidden;">
  <div id="sidebar">
    <label>Floor Space Size (ft):</label>
    <label>Width (ft): <input type="number" id="inputWidth" value="1"></label>
    <label>Length (ft): <input type="number" id="inputLength" value="1"></label>
    <div style="display: flex; justify-content: space-between; gap: 5px;">
      <button onclick="generateGrid()">Create Grid</button>
      <button onclick="toggleGridOpacity()" id="gridToggleBtn">Hide Grid Lines</button>
    </div>
    <hr>
    <label>Custom Space Size (ft):</label>
    <input type="number" id="customWidth" placeholder="Width (ft)" min="2" step="2">
    <input type="number" id="customHeight" placeholder="Height (ft)" min="2" step="2">
    <button onclick="enablePlacement(true)" style="flex: 1 1 50%; font-size: 12px; padding: 4px;">Place Custom Booth</button>
    <div style="margin-bottom: 10px;">
  <strong style="font-size: 12px;">Quick Sizes:</strong><br>
  <div style="display: flex; gap: 5px; flex-wrap: wrap;">
    <button type="button" onclick="setBoothSize(8, 8)" style="flex: 1 1 25%; font-size: 12px; padding: 4px;">8x8</button>
    <button type="button" onclick="setBoothSize(10, 10)" style="flex: 1 1 25%; font-size: 12px; padding: 4px;">10x10</button>
    <button type="button" onclick="setBoothSize(10, 20)" style="flex: 1 1 25%; font-size: 12px; padding: 4px;">10x20</button>
    <button type="button" onclick="setBoothSize(20, 10)" style="flex: 1 1 25%; font-size: 12px; padding: 4px;">20x10</button>
  </div>
</div>
    <label>Booth Type:
      <select id="boothType">
        <option value="Vendor">Vendor</option>
        <option value="Artist">Artist</option>
        <option value="Guest">Guest</option>
        <option value="Stage">Stage</option>
        <option value="Food">Food</option>
        <option value="Photo Op">Photo Op</option>
      </select>
    </label>
    <label>Label: <input type="text" id="boothLabel" placeholder="e.g. Vendor A1"></label>
    <hr>
    <div style="display: flex; justify-content: space-between; gap: 5px; margin-bottom: 10px;">
      <button onclick="scrollToCenter()" title="Center View" style="padding: 4px 6px; font-size: 12px; width: 33%;">Center View</button>
      <button onclick="duplicateSelectedBooth()" title="Duplicate Booth" style="padding: 4px 6px; font-size: 20px; width: 33%;">üìÑ</button>
      <button onclick="deleteSelectedBooth()" title="Delete Booth" style="padding: 4px 6px; font-size: 20px; width: 33%;">üóëÔ∏è</button>
    </div>
    <div style="display: flex; justify-content: space-between; gap: 5px;">
      <button onclick="saveLayout()" title="Save Layout" style="padding: 4px 6px; font-size: 20px; width: 33%;">üíæ</button>
      <button onclick="loadLayout()" title="Load Layout" style="padding: 4px 6px; font-size: 20px; width: 33%;">üìÇ</button>
    <button onclick="exportToPDF()" title="Export as PDF" style="padding: 4px 6px; font-size: 20px; width: 33%;">üìÑ</button>
    </div>
    <div style="display: flex; justify-content: space-between; gap: 5px; margin-top: 10px;">
      <button onclick="undoLayout()" style="width: 48%;">Undo</button>
      <button onclick="redoLayout()" style="width: 48%;">Redo</button>
    </div>
    <hr>
    <label>Zoom:
      <input type="range" id="zoomSlider" min="0.5" max="2" step="0.1" value="1" onchange="updateZoom()">
    </label>
    <hr>
    <div style="max-height: 250px; overflow-y: auto; border: 1px solid #ccc; padding: 8px; background: #fff; margin-top: 10px;">
      <div id="boothList"></div>
    </div>
    <label for="searchBooths">Search Booths:</label>
    <input type="text" id="searchBooths" placeholder="Type to search..." oninput="filterBoothList()" style="margin-bottom: 10px;">
    <button onclick="exportBoothListToCSV()" title="Export Booth List CSV" style="padding: 4px 6px; font-size: 14px; margin-top: 10px;">‚¨á Export Booth List CSV</button>
  </div>

  <div id="grid-container">
    <div id="grid-wrapper">
      <div id="grid"></div>
    </div>
  </div>

  <script>
    const cellSizeFt = 2;
    const cellPx = 20;
    let isPlacing = false;
    let selectedBooth = null;
    
    window.addEventListener('keydown', e => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault(); // Prevent page scrolling from arrow keys
      }
    }, { passive: false });

    let boothCounter = 0;
    let boothWidth = 5;
    let boothHeight = 5;
    let history = [];
    let redoStack = [];
    let currentZoom = 1;
    const originalMouseMove = (moveEvent, booth, offsetX, offsetY, grid) => {
      const rect = grid.getBoundingClientRect();
      const x = (moveEvent.clientX - rect.left) / currentZoom - offsetX;
      const y = (moveEvent.clientY - rect.top) / currentZoom - offsetY;
      const snappedLeft = Math.round(x / cellPx) * cellPx;
      const snappedTop = Math.round(y / cellPx) * cellPx;

      const boothWidth = parseInt(booth.style.width);
      const boothHeight = parseInt(booth.style.height);
      const gridWidth = grid.offsetWidth;
      const gridHeight = grid.offsetHeight;

      const withinBounds = snappedLeft >= 0 && snappedTop >= 0 &&
                          snappedLeft + boothWidth <= gridWidth &&
                          snappedTop + boothHeight <= gridHeight;

      const otherBooths = Array.from(document.querySelectorAll('.booth')).filter(b => b !== booth);
      const overlapping = otherBooths.some(b => {
        const bx = parseInt(b.style.left);
        const by = parseInt(b.style.top);
        const bw = parseInt(b.style.width);
        const bh = parseInt(b.style.height);
        return snappedLeft < bx + bw && snappedLeft + boothWidth > bx &&
               snappedTop < by + bh && snappedTop + boothHeight > by;
      });

      if (withinBounds && !overlapping) {
        booth.style.transform = `translate(${snappedLeft}px, ${snappedTop}px)`;

        // OPTIONAL: if you want to also retain booth.style.left/top for saving/exporting layout info:
        booth.dataset.translateX = snappedLeft;
        booth.dataset.translateY = snappedTop;
      }
    };

    function throttle(callback, limit) {
      let waiting = false;
      return function () {
        if (!waiting) {
          callback.apply(this, arguments);
          waiting = true;
          setTimeout(() => {
            waiting = false;
          }, limit);
        }
      };
    }
    
    function attachThrottledMouseEvents(booth, offsetX, offsetY, grid) {
      const throttledMouseMove = throttle((moveEvent) => {
        originalMouseMove(moveEvent, booth, offsetX, offsetY, grid);
      }, 16);

      function onMouseUp() {
        document.removeEventListener('mousemove', throttledMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      }

      document.addEventListener('mousemove', throttledMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    }
    
    function generateGrid() {
      const widthFt = parseInt(document.getElementById('inputWidth').value);
      const lengthFt = parseInt(document.getElementById('inputLength').value);
      const cols = Math.floor(widthFt / cellSizeFt);
      const rows = Math.floor(lengthFt / cellSizeFt);

      const grid = document.getElementById('grid');
      grid.innerHTML = '';
      grid.style.gridTemplateColumns = `repeat(${cols}, ${cellPx}px)`;
      grid.style.gridTemplateRows = `repeat(${rows}, ${cellPx}px)`;
      grid.style.width = `${cols * cellPx}px`;
      grid.style.height = `${rows * cellPx}px`;

      for (let i = 0; i < rows * cols; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.index = i;
        grid.appendChild(cell);
      }
    }

    function enablePlacement(isCustom = false) {
      isPlacing = true;
      const grid = document.getElementById('grid');
      const type = document.getElementById('boothType').value;
      const label = document.getElementById('boothLabel').value;
      let w = 5, h = 5;

      if (isCustom) {
        const customW = parseInt(document.getElementById('customWidth').value);
        const customH = parseInt(document.getElementById('customHeight').value);
        if (!isNaN(customW)) boothWidth = customW;
        if (!isNaN(customH)) boothHeight = customH;
      }

      grid.onclick = function(e) {
        if (!isPlacing || !e.target.classList.contains('cell')) return;
        isPlacing = false;
        
        const rect = grid.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const left = Math.round(x / cellPx) * cellPx;
        const top = Math.round(y / cellPx) * cellPx;

        const booth = document.createElement('div');
        const w = boothWidth / cellSizeFt;
        const h = boothHeight / cellSizeFt;
        const type = document.getElementById('boothType').value;
        const label = document.getElementById('boothLabel').value;
        
        booth.className = `booth ${type}`;
        booth.style.transform = `translate(${left}px, ${top}px)`;
        booth.dataset.translateX = left;
        booth.dataset.translateY = top;
        booth.style.width = `${w * cellPx}px`;
        booth.style.height = `${h * cellPx}px`;
        booth.textContent = label || `${w * cellSizeFt}x${h * cellSizeFt}`;
        booth.setAttribute('tabindex', 0);
        booth.dataset.rotation = 0;
        booth.dataset.label = label;
        booth.dataset.type = type;
        booth.dataset.index = ++boothCounter;

        booth.addEventListener('click', function(ev) {
          document.querySelectorAll('.booth.selected').forEach(b => b.classList.remove('selected'));
          booth.classList.add('selected');
          selectedBooth = booth;
          ev.stopPropagation();
        });

        booth.addEventListener('mousedown', function(ev) {
          const boothRect = booth.getBoundingClientRect();
          const offsetX = (ev.clientX - boothRect.left) / currentZoom;
          const offsetY = (ev.clientY - boothRect.top) / currentZoom;
          const grid = document.getElementById('grid');
          attachThrottledMouseEvents(booth, offsetX, offsetY, grid);
        });

        grid.appendChild(booth);
        updateBoothList();
        saveHistory();
      }
    }

    function setBoothSize(width, height) {
      document.getElementById('customWidth').value = width;
      document.getElementById('customHeight').value = height;
      boothWidth = width;
      boothHeight = height;
      enablePlacement(true);
    }

    function deleteSelectedBooth() {
      if (selectedBooth) {
        selectedBooth.remove();
        selectedBooth = null;
        updateBoothList();
        saveHistory();
      }
    }

    function updateBoothList() {
      const boothList = document.getElementById('boothList');
      const search = document.getElementById('searchBooths')?.value.toLowerCase() || '';
      boothList.innerHTML = '<strong>Booth List:</strong>';

      const booths = Array.from(document.querySelectorAll('.booth'));

      // Group booths by type
      const groups = {};
      booths.forEach(booth => {
        const type = booth.dataset.type || 'Other';
        if (!groups[type]) groups[type] = [];
        groups[type].push(booth);
      });

      // Sort groups alphabetically
      Object.keys(groups).sort().forEach(type => {
        const matchingBooths = groups[type].filter(booth => {
          const label = booth.dataset.label?.toLowerCase() || booth.textContent.toLowerCase();
          return label.includes(search) || type.toLowerCase().includes(search);
        });

        if (matchingBooths.length > 0) {
          boothList.innerHTML += `<div style="margin-top: 8px; font-weight: bold;">${type}</div>`;
          matchingBooths.forEach(booth => {
            const id = booth.dataset.index;
            const label = booth.dataset.label || booth.textContent;
            boothList.innerHTML += `
              <div style="margin-left: 10px; display: flex; align-items: center; justify-content: space-between;">
                <span style="cursor: pointer;" onclick="highlightBooth(${id})">#${id}: ${label}</span>
                <button onclick="editLabel(${id})" title="Rename Booth"
                  style="font-size: 16px; width: 24px; height: 24px; padding: 0; line-height: 1; margin-left: 5px; text-align: center;">‚úèÔ∏è</button>
              </div>`;
          });
        }
      });
    }

    function highlightBooth(index) {
      const booth = Array.from(document.querySelectorAll('.booth')).find(b => b.dataset.index == index);
      if (!booth) return;

      // Flash the booth with a yellow outline briefly
      booth.style.outline = '3px solid gold';
      booth.style.zIndex = 1000;

      setTimeout(() => {
        booth.style.outline = '';
        booth.style.zIndex = '';
      }, 1200);
    }

    function filterBoothList() {
      updateBoothList(); // will respect the live search filter
    }

    function editLabel(index) {
      const booth = Array.from(document.querySelectorAll('.booth')).find(b => b.dataset.index == index);
      if (!booth) return;

      const newLabel = prompt("Enter a new label:", booth.dataset.label || booth.textContent);
      if (newLabel !== null && newLabel.trim() !== "") {
        booth.dataset.label = newLabel.trim();
        booth.textContent = newLabel.trim();
        updateBoothList();
        saveHistory();
      }
    }

    function updateZoom() {
      currentZoom = parseFloat(document.getElementById('zoomSlider').value); // ‚úÖ Save zoom
      const wrapper = document.getElementById('grid-wrapper');
      wrapper.style.transform = `scale(${currentZoom})`;
      wrapper.style.transformOrigin = 'top center'; 
    }

    let gridVisible = true;

    function toggleGridOpacity() {
      const cells = document.querySelectorAll('.cell');
      gridVisible = !gridVisible;

      cells.forEach(cell => {
        cell.style.borderColor = gridVisible ? 'rgba(0, 0, 0, 0.2)' : 'transparent';
      });

      const btn = document.getElementById('gridToggleBtn');
      btn.textContent = gridVisible ? 'Hide Grid Lines' : 'Show Grid Lines';
    }

    function saveLayout() {
      const booths = Array.from(document.querySelectorAll('.booth')).map(booth => ({
        translateX: booth.dataset.translateX || 0,
        translateY: booth.dataset.translateY || 0,
        width: booth.style.width,
        height: booth.style.height,
        rotation: booth.dataset.rotation || 0,
        label: booth.dataset.label || '',
        type: booth.dataset.type || '',
        index: booth.dataset.index || ''
      }));
      localStorage.setItem('cosplayLayout', JSON.stringify(booths));
      alert('Layout saved!');
    }

    function loadLayout() {
      const saved = localStorage.getItem('cosplayLayout');
      if (!saved) return alert('No saved layout found.');
      const booths = JSON.parse(saved);

      const grid = document.getElementById('grid');
      grid.innerHTML = ''; // Clear current layout
      generateGrid(); // Redraw grid

      booths.forEach(data => {
        const booth = document.createElement('div');
        booth.className = `booth ${data.type}`;
        booth.dataset.translateX = data.translateX;
        booth.dataset.translateY = data.translateY;
        booth.style.transform = `translate(${data.translateX}px, ${data.translateY}px) rotate(${data.rotation}deg)`;
        booth.style.width = data.width;
        booth.style.height = data.height;
        booth.textContent = data.label;
        booth.setAttribute('tabindex', 0);
        booth.dataset.rotation = data.rotation;
        booth.dataset.label = data.label;
        booth.dataset.type = data.type;
        booth.dataset.index = data.index;
    
        booth.addEventListener('click', function(ev) {
          document.querySelectorAll('.booth.selected').forEach(b => b.classList.remove('selected'));
          booth.classList.add('selected');
          selectedBooth = booth;
          ev.stopPropagation();
        });

        booth.addEventListener('mousedown', function(ev) {
          const boothRect = booth.getBoundingClientRect();
          const offsetX = (ev.clientX - boothRect.left) / currentZoom;
          const offsetY = (ev.clientY - boothRect.top) / currentZoom;
          const grid = document.getElementById('grid');
          attachThrottledMouseEvents(booth, offsetX, offsetY, grid);
        });


        grid.appendChild(booth);
      });

      updateBoothList();
    }

    function exportToPDF() {
      if (!window.jspdf || !window.jspdf.jsPDF) {
        alert("jsPDF is not loaded.");
        return;
      }

      const jsPDF = window.jspdf.jsPDF;

      html2canvas(document.getElementById('grid-wrapper')).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const pdf = new jsPDF({
          orientation: 'landscape',
          unit: 'px',
          format: [canvas.width, canvas.height]
        });

        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
        pdf.save('layout.pdf');
      }).catch(err => {
        console.error('html2canvas error:', err);
        alert('Failed to export layout. See console for details.');
      });
    }

    function exportBoothListToCSV() {
      const booths = Array.from(document.querySelectorAll('.booth'));

      const rows = [["Index", "Type", "Label", "Width (ft)", "Height (ft)", "X (ft)", "Y (ft)"]];

      booths.forEach(booth => {
        const index = booth.dataset.index;
        const type = booth.dataset.type;
      const label = booth.dataset.label || booth.textContent;

        const widthPx = parseInt(booth.style.width);
        const heightPx = parseInt(booth.style.height);
        const xPx = parseInt(booth.style.left);
        const yPx = parseInt(booth.style.top);

        const widthFt = (widthPx / cellPx) * cellSizeFt;
        const heightFt = (heightPx / cellPx) * cellSizeFt;
        const xFt = (xPx / cellPx) * cellSizeFt;
        const yFt = (yPx / cellPx) * cellSizeFt;

        rows.push([index, type, label, widthFt, heightFt, xFt, yFt]);
      });

      const csvContent = rows.map(row => row.join(",")).join("\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.setAttribute("href", url);
      link.setAttribute("download", "booth-list.csv");
      link.style.display = "none";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    document.addEventListener('keydown', function(e) {
      if (e.key === 'Delete' && selectedBooth) {
        selectedBooth.remove();
        selectedBooth = null;
        updateBoothList();
        saveHistory();
      }

      if (selectedBooth) {
        const step = cellPx;

        let x = parseInt(selectedBooth.dataset.translateX || 0);
        let y = parseInt(selectedBooth.dataset.translateY || 0);

        if (e.key === 'ArrowUp') {
          e.preventDefault();
          y -= step;
        }
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          y += step;
        }
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          x -= step;
        }
        if (e.key === 'ArrowRight') {
          e.preventDefault();
          x += step;
        }

        selectedBooth.style.transform = `translate(${x}px, ${y}px)`;
        selectedBooth.dataset.translateX = x;
        selectedBooth.dataset.translateY = y;
      }
    });;

    function scrollToCenter() {
      const container = document.getElementById('grid-container');
      const wrapper = document.getElementById('grid-wrapper');

      const scrollLeft = (wrapper.offsetWidth * parseFloat(document.getElementById('zoomSlider').value) - container.clientWidth) / 2;
      container.scrollLeft = scrollLeft;
    }

    function duplicateSelectedBooth() {
    if (!selectedBooth) return;

    const original = selectedBooth;
    const clone = original.cloneNode(true);
    const grid = document.getElementById('grid');

    const left = parseInt(original.dataset.translateX || 0) + 80;
    const top = parseInt(original.dataset.translateY || 0) + 0;
    clone.style.transform = `translate(${left}px, ${top}px)`;
    clone.dataset.translateX = left;
    clone.dataset.translateY = top;

    clone.dataset.index = ++boothCounter;
    clone.setAttribute('tabindex', 0);
    const w = parseInt(clone.style.width) / cellPx * cellSizeFt;
    const h = parseInt(clone.style.height) / cellPx * cellSizeFt;
    const label = original.dataset.label;
    clone.textContent = label && label.trim() !== "" ? label : `${w}x${h}`;
    clone.dataset.label = label || "";


    clone.addEventListener('click', function(ev) {
      document.querySelectorAll('.booth.selected').forEach(b => b.classList.remove('selected'));
      clone.classList.add('selected');
      selectedBooth = clone;
      ev.stopPropagation();
    });

    clone.addEventListener('mousedown', function(ev) {
      const boothRect = booth.getBoundingClientRect();
      const offsetX = (ev.clientX - boothRect.left) / currentZoom;
      const offsetY = (ev.clientY - boothRect.top) / currentZoom;
      const grid = document.getElementById('grid');
      attachThrottledMouseEvents(clone, offsetX, offsetY, grid);
    });

      grid.appendChild(clone);
      updateBoothList();
      saveHistory();
    }

    function saveHistory() {
      const snapshot = Array.from(document.querySelectorAll('.booth')).map(booth => ({
        translateX: booth.dataset.translateX,
        translateY: booth.dataset.translateY,
        width: booth.style.width,
        height: booth.style.height,
        rotation: booth.dataset.rotation,
        label: booth.dataset.label,
        type: booth.dataset.type,
      index: booth.dataset.index
      }));

      history.push(snapshot);
      if (history.length > 50) history.shift(); // Limit history size
      redoStack = []; // Clear redo stack on new action
    }

    function undoLayout() {
      if (history.length === 0) return;
      const current = Array.from(document.querySelectorAll('.booth')).map(b => b.remove());
      const previous = history.pop();
      redoStack.push(previous);
      restoreLayout(previous);
    }

    function redoLayout() {
      if (redoStack.length === 0) return;
      const redoState = redoStack.pop();
      history.push(redoState);
      restoreLayout(redoState);
    }

    function restoreLayout(layout) {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';
      generateGrid();

      layout.forEach(data => {
        const booth = document.createElement('div');
        booth.className = `booth ${data.type}`;
        booth.dataset.translateX = data.translateX;
        booth.dataset.translateY = data.translateY;
        booth.style.transform = `translate(${data.translateX}px, ${data.translateY}px) rotate(${data.rotation}deg)`;
        booth.style.width = data.width;
        booth.style.height = data.height;
        booth.textContent = data.label;
        booth.setAttribute('tabindex', 0);
        booth.dataset.rotation = data.rotation;
        booth.dataset.label = data.label;
        booth.dataset.type = data.type;
        booth.dataset.index = data.index;

        booth.addEventListener('click', function(ev) {
          document.querySelectorAll('.booth.selected').forEach(b => b.classList.remove('selected'));
          booth.classList.add('selected');
          selectedBooth = booth;
          ev.stopPropagation();
        });

        booth.addEventListener('mousedown', function(ev) {
          const boothRect = booth.getBoundingClientRect();
          const offsetX = (ev.clientX - boothRect.left) / currentZoom;
          const offsetY = (ev.clientY - boothRect.top) / currentZoom;
          const grid = document.getElementById('grid');
          attachThrottledMouseEvents(booth, offsetX, offsetY, grid);
        });

        grid.appendChild(booth);
      });

      updateBoothList();
    }
    
</script>
  </main>
  <footer style="background:#f4f4f4;text-align:center;padding:10px;font-size:0.9em;border-top:1px solid #ccc;">
    &copy; 2025 by <a href="https://IllionMedia.com" target="_blank" style="color:#000;text-decoration:none;font-weight:bold;">Illion Media Group</a>
  </footer>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

</body>
</html>
